## Exercise 2.60

We specified that a set would be represented as a list with no duplicates. Now
suppose we allow duplicates. For instance, the set {1,2,3} could be represented
as the list `(2 3 2 1 3 2 2)`. Design procedures `element-of-set?`,
`adjoin-set`, `union-set`, and `intersection-set` that operate on this
representation. How does the efficiency of each compare with the corresponding
procedure for the non-duplicate representation? Are there applications for which
you would use this representation in preference to the non-duplicate one?

## Solution

### `element-of-set?`

The implementation stays the same:

```scheme
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
```

The efficienty compared to the non-duplicate representation stays the same: in
order to check whether an object is a member of a set, `element-of-set?` may
have to scan the entire set. The number of steps required grows as $Θ(n)$.

But it is worth mentioning that, with duplicates allowed, the physical list can
become longer for the same logical set size. So, if we let $k$ to be the
duplication factor, a logical set with $n$ elements becomes $kn$ elements in
total. This is stil $Θ(n)$ growth, but with a factor of $k$ times in number of
steps over the previous implementation.

### `adjoin-set`

The implementation becomes much simpler:

```scheme
(define (adjoin-set x set)
  (cons x set))
```

Because we don't need to scan the set looking for duplicates, we have an
increase in the efficiency compared to the non-duplicate representation. The
number of steps required grows as $Θ(1)$ rather than $Θ(n)$, because we are just
prepending an element to the set.

### `union-set`

Because duplicates are permitted, we do not need to filter either list; the
union is simply the concatenation of `set1` and `set2`:

```scheme
(define (union-set set1 set2)
  (append set1 set2))
```

It is important to realize, though, that the `append` is not a constant time
operation like `cons`. We need to walk through the first list copying their
elements; the second list is reused through structural sharing. If we would
"look under the hood" to see what `append` is doing we would have something like
this:

```scheme
(define (union-set set1 set2)
  (if (null? set1)
    set2
    (cons (car set1)
          (union-set (cdr set1) set2))))
```

Nevertheless, because we don't need to scan the sets looking for duplicates, we
still have an increase in the efficiency compared to the non-duplicate
representation.

#### Duplication-free representation

- Must check duplicates as it builds the new set
- That leads to roughtly $n \times m$ calls, so $Θ(m \cdot n)$
- If the sets are of similar size, $Θ(n^2)$

#### Duplicate-allowed representation

- Need to walk through the first set. So, if set1 has size $n$, $Θ(n)$

### intersection-set

The implementation stays the same:

```scheme
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2))
         '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1)
                                 set2)))
        (else (intersection-set (cdr set1)
                                set2))))
```

The efficienty compared to the non-duplicate representation also stays the same:
in order to check whether an object is member of the 2 sets, `intersection-set`
may need to call `element-of-set?` for each element of the set

#### Duplication-free representation

- Must check whether each element of `set1` is a member of `set2`
- That leads to roughtly $n \times m$ calls, so $Θ(m \cdot n)$
- If the sets are of similar size, $Θ(n^2)$

#### Duplicate-allowed representation

- Must check whether each element of `set1` is a member of `set2`
- That leads to roughtly $n \times m$ calls, so $Θ(m \cdot n)$
- If the sets are of similar size, $Θ(n^2)$

But it is worth mentioning that, with duplicates allowed, the physical list can
become longer for the same logical set size. So, if we let $k$ to be the
duplication factor, a logical set with $n$ elements becomes $kn$ elements in
total. This is stil $Θ(n^2)$ growth, but with a factor of $k$ times in number of
steps over the previous implementation.

Also, in the duplicate-allowed representation, we may end up generating an
intersection with duplicates dependeing on how you interpret "intersection".

### Are there applications for which you would use this representation in preference to the non-duplicate one?

The duplicate-allowed representation is useful if we are designing some
application where we want something like bag-like without counting:

- Heavy bulk additions are $Θ(1)$
- Infrequent membership queries
- No need for set invariants

On the other hand, it is important to also spot the downsides of this
representation:

1. Duplicate-allowed "sets" don't satisfy set invariants
2. Operations like intersection can produce results that do not correspond to
   standard set-theoretic intersection (do you keep multiple copies of a common
   element?)
