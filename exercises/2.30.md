## Exercise 2.30

Define a procedure `square-tree` analogous to the `square-list` procedure of
[Exercise 2.21](./2.21.md). That is, `square-tree` should behave as follows:

```scheme
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
(1 (4 (9 16) 25) (36 49))
```

Define `square-tree` both directly (i.e., without using any higher-order
procedures) and also by using `map` and recursion.

## Solution

### Directly

```scheme
(define (square-tree tree)
  (cond ((null? tree) '())
        ((pair? tree) (cons (square-tree (car tree))
                            (square-tree (cdr tree))))
        (else (square tree))))
```

This implementation operates directly on the pair structure, but it is also more
flexible because it can operate on trees that are represented as either proper
or improper lists.

### Using higher-order procedures

```scheme
(define (square-tree tree)
  (map (lambda (child)
         (if (pair? child)
           (square-tree child)
           (square child)))
       tree))
```

Although this implementation would work for proper lists, for improper lists we
would have a problem because `map` expects a list that ends with `'()`. To solve
this problem and still have the ability to use higher-order procedures, we can
generalize the `map` procedure:

```scheme
(define (tree-map fn tree)
  (cond ((null? tree) '())
        ((pair? tree) (cons (tree-map fn (car tree))
                            (tree-map fn (cdr tree))))
        (else (fn tree))))

(define (square-tree tree)
  (tree-map square tree))
```
