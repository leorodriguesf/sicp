## Exercise 2.46

A two-dimensional vector **v** running from the origin to a point can be
represented as a pair consisting of an $x$-coordinate and a $y$-coordinate.
Implement a data abstraction for vectors by giving a constructor `make-vect` and
corresponding selectors `xcor-vect` and `ycor-vect`. In terms of your selectors
and constructor, implement procedures `add-vect`, `sub-vect`, and `scale-vect`
that perform the operations vector addition, vector subtraction, and multiplying
a vector by a scalar:

$$
(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2),
$$

$$
(x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2),
$$

$$
s \cdot (x, y) = (sx, sy).
$$

## Solution

```scheme
(define (make-vect x y)
  (cons x y))

(define (xcor-vect vect)
  (car vect))

(define (ycor-vect vect)
  (cdr vect))

(define (add-vect vector1 vector2)
  (make-vect
    (+ (xcor-vect vector1) (xcor-vect vector2))
    (+ (ycor-vect vector1) (ycor-vect vector2))))

(define (sub-vect vector1 vector2)
  (make-vect
    (- (xcor-vect vector1) (xcor-vect vector2))
    (- (ycor-vect vector1) (ycor-vect vector2))))

(define (scale-vect factor vect)
  (make-vect
    (* factor (xcor-vect vect))
    (* factor (ycor-vect vect))))
```

Note that, for our constructors and selectors, we are not just define them as
**bindings**:

```scheme
(define make-vect cons)
(define xcor-vect car)
(define ycor-vect cdr)
```

And instead we are defining them as **wrappers**:

```scheme
(define (make-vect x y)
  (cons x y))

(define (xcor-vect vect)
  (car vect))

(define (ycor-vect vect)
  (cdr vect))
```

Although they look like the same, and in practice they will give the same
result, they still have a conceptual difference: aliasing collapses the
abstraction into the primitive, while wrapping creates a distict abstraction.
