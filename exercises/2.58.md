## Exercise 2.58

Suppose we want to modify the differentiation program so that it works with
ordinary mathematical notation, in which `+` and `*` are infix rather than
prefix operators. Since the differentiation program is defined in terms of
abstract data, we can modify it to work with different representations of
expressions solely by changing the predicates, selectors, and constructors that
define the representation of the algebraic expressions on which the
differentiator is to operate.

1. Show how to do this in order to differentiate algebraic expressions presented
   in infix form, such as `(x + (3 * (x + (y + 2))))`. To simplify the task,
   assume that `+` and `*` always take two arguments and that expressions are
   fully parenthesized.
2. The problem becomes substantially harder if we allow standard algebraic
   notation, such as `(x + 3 * (x + y + 2))`, which drops unnecessary
   parentheses and assumes that multiplication is done before addition. Can you
   design appropriate predicates, selectors, and constructors for this notation
   such that our derivative program still works?

## Solution

### Solution to subproblem 1

Because our differentiation program is using abstract data to represent sums and
prodcuts, we only need a small change on the predicates, selectors, and
constructors:

```diff
(define (sum? exp)
  (and (pair? exp)
-       (eq? (car exp) '+)))
+       (eq? (cadr exp) '+)))

(define (make-sum x y)
  (cond ((=number? x 0) y)
        ((=number? y 0) x)
        ((and (number? x)
              (number? y))
         (+ x y))
-        (else (list '+ x y))))
+        (else (list x '+ y))))

-(define (addend exp) (cadr exp))
+(define (addend exp) (car exp))
(define (augend exp) (caddr exp))

(define (product? exp)
  (and (pair? exp)
-       (eq? (car exp) '*)))
+       (eq? (cadr exp) '*)))

(define (make-product x y)
  (cond ((or (=number? x 0)
             (=number? y 0))
         0)
        ((=number? x 1) y)
        ((=number? y 1) x)
        ((and (number? x)
              (number? y))
         (* x y))
-        (else (list '* x y))))
+        (else (list x '* y))))

-(define (multiplier exp) (cadr exp))
+(define (multiplier exp) (car exp))
(define (multiplicand exp) (caddr exp))
```

The result is shown below:

```scheme
(define ** expt)

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product
             (multiplier exp)
             (deriv (multiplicand exp) var))
           (make-product
             (deriv (multiplier exp) var)
             (multiplicand exp))))
        (else (error "unknown expression
                     type: DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? x y)
  (and (variable? x)
       (variable? y)
       (eq? x y)))

(define (sum? exp)
  (and (pair? exp)
       (eq? (cadr exp) '+)))

(define (make-sum x y)
  (cond ((=number? x 0) y)
        ((=number? y 0) x)
        ((and (number? x)
              (number? y))
         (+ x y))
        (else (list x '+ y))))
(define (addend exp) (car exp))
(define (augend exp) (caddr exp))

(define (product? exp)
  (and (pair? exp)
       (eq? (cadr exp) '*)))

(define (make-product x y)
  (cond ((or (=number? x 0)
             (=number? y 0))
         0)
        ((=number? x 1) y)
        ((=number? y 1) x)
        ((and (number? x)
              (number? y))
         (* x y))
        (else (list x '* y))))

(define (multiplier exp) (car exp))
(define (multiplicand exp) (caddr exp))

(define (=number? exp num)
  (and (number? exp)
       (= exp num)))
```

### Solution to subproblem 2

To solve this subproblem, we need some helper functions, and we also need to
modify our predicates and selectors:

```diff
(define (has? op exp)
  (and (pair? exp)
       (if (memq op exp) #t #f)))

(define (unwrap exp)
  (if (and (pair? exp) (null? (cdr exp)))
    (car exp)
    exp))

(define (before op exp)
  (if (eq? op (car exp))
    '()
    (unwrap (cons (car exp) (before op (cdr exp))))))

(define (after op exp)
  (unwrap (cdr (memq op exp))))

-(define (sum? exp)
-  (and (pair? exp)
-       (eq? (cadr exp) '+)))
+(define (sum? exp) (has? '+ exp))

-(define (addend exp) (car exp))
+(define (addend exp) (before '+ exp))

-(define (augend exp) (caddr exp))
+(define (augend exp) (after '+ exp))

-(define (product? exp)
-  (and (pair? exp)
-       (eq? (cadr exp) '*)))
+(define (product? exp)
+  (and (not (sum? exp))
+            (has? '* exp)))

-(define (multiplier exp) (car exp))
+(define (multiplier exp) (before '* exp))

-(define (multiplicand exp) (caddr exp))
+(define (multiplicand exp) (after '* exp))
```

The result is shown below:

```scheme
(define ** expt)

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product
             (multiplier exp)
             (deriv (multiplicand exp) var))
           (make-product
             (deriv (multiplier exp) var)
             (multiplicand exp))))
        (else (error "unknown expression
                     type: DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? x y)
  (and (variable? x)
       (variable? y)
       (eq? x y)))

(define (has? op exp)
  (and (pair? exp)
       (if (memq op exp) #t #f)))

(define (before op exp)
  (if (eq? op (car exp))
    '()
    (unwrap (cons (car exp) (before op (cdr exp))))))

(define (after op exp)
  (unwrap (cdr (memq op exp))))

(define (unwrap exp)
  (if (and (pair? exp) (null? (cdr exp)))
    (car exp)
    exp))

(define (sum? exp) (has? '+ exp))

(define (make-sum x y)
  (cond ((=number? x 0) y)
        ((=number? y 0) x)
        ((and (number? x)
              (number? y))
         (+ x y))
        (else (list x '+ y))))
(define (addend exp) (before '+ exp))
(define (augend exp) (after '+ exp))

(define (product? exp)
  (and (not (sum? exp))
            (has? '* exp)))

(define (make-product x y)
  (cond ((or (=number? x 0)
             (=number? y 0))
         0)
        ((=number? x 1) y)
        ((=number? y 1) x)
        ((and (number? x)
              (number? y))
         (* x y))
        (else (list x '* y))))

(define (multiplier exp) (before '* exp))
(define (multiplicand exp) (after '* exp))

(define (=number? exp num)
  (and (number? exp)
       (= exp num)))
```
