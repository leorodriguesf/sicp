## Exercise 2.74

Insatiable Enterprises, Inc., is a highly decentralized conglomerate company
consisting of a large number of independent divisions located all over the
world. The company’s computer facilities have just been interconnected by means
of a clever network-interfacing scheme that makes the entire network appear to
any user to be a single computer. Insatiable’s president, in her first attempt
to exploit the ability of the network to extract administrative information from
division files, is dismayed to discover that, although all the division files
have been implemented as data structures in Scheme, the particular data
structure used varies from division to division. A meeting of division managers
is hastily called to search for a strategy to integrate the files that will
satisfy headquarters’ needs while preserving the existing autonomy of the
divisions.

Show how such a strategy can be implemented with data-directed programming. As
an example, suppose that each division’s personnel records consist of a single
file, which contains a set of records keyed on employees’ names. The structure
of the set varies from division to division. Furthermore, each employee’s record
is itself a set (structured differently from division to division) that contains
information keyed under identifiers such as `address` and `salary`. In
particular:

1. Implement for headquarters a `get-record` procedure that retrieves a
   specified employee’s record from a specified personnel file. The procedure
   should be applicable to any division’s file. Explain how the individual
   divisions’ files should be structured. In particular, what type information
   must be supplied?
2. Implement for headquarters a `get-salary` procedure that returns the salary
   information from a given employee’s record from any division’s personnel
   file. How should the record be structured in order to make this operation
   work?
3. Implement for headquarters a `find-employee-record` procedure. This should
   search all the divisions’ files for the record of a given employee and return
   the record. Assume that this procedure takes as arguments an employee’s name
   and a list of all the divisions’ files.
4. When Insatiable takes over a new company, what changes must be made in order
   to incorporate the new personnel information into the central system?

## Solution

### Subproblem 1

The implementation of `get-record` for headquarters will only be responsible for
calling the division's internal procedure of `get-record`:

```scheme
(define (get-record employee-name file)
  (let* ((tag (type-tag file))
         (proc (get 'get-record tag)))
    (if proc
      (proc employee-name (contents file))
      (error
        "No method for type:
        GET-RECORD"
        tag))))
```

The implementation shows that the only information carried by the file that
headquartes requires is the division tag.

In addition, each division:

- Install (exposes to the rest of the system) its own implementation of
  `get-record` that deals with its internal set structure
- Tag the file with a symbol

```scheme
(define (install-marketing-package)
  ;; Internal procedures
  (define (get-record name records)
    (cond ((null? records) #f)
          ((equal? name (car records)) name)
          (else (get-record name (cdr records)))))
  ;; Interface to the rest of the system
  (put 'get-record 'marketing get-record)
  'done)

(define (install-sales-package)
  ;; Internal procedures
  (define (key record) (car record))
  (define (get-record name records)
    (cond ((null? records) #f)
          ((equal? name (key (car records))) (car records))
          (else (get-record name (cdr records)))))
  ;; Interface to the rest of the system
  (put 'get-record 'sales get-record)
  'done)

(define marketing-file (attach-tag 'marketing
                                   '("John" "Pedro" "Alice")))

(define sales-file (attach-tag 'sales
                               '(("Doe" 27) ("Pedro" 40) ("Alice" 60))))
```

Here is an example of a company with two divisions:

```scheme
(define (install-marketing-package)
  ;; Internal procedures
  (define (get-record name records)
    (cond ((null? records) #f)
          ((equal? name (car records)) name)
          (else (get-record name (cdr records)))))
  ;; Interface to the rest of the system
  (put 'get-record 'marketing get-record)
  'done)

(define (install-sales-package)
  ;; Internal procedures
  (define (key record) (car record))
  (define (get-record name records)
    (cond ((null? records) #f)
          ((equal? name (key (car records))) (car records))
          (else (get-record name (cdr records)))))
  ;; Interface to the rest of the system
  (put 'get-record 'sales get-record)
  'done)

(define (get-record employee-name file)
  (let* ((tag (type-tag file))
         (proc (get 'get-record tag)))
    (if proc
      (proc employee-name (contents file))
      (error
        "No method for type:
        GET-RECORD"
        tag))))

(install-marketing-package)
(install-sales-package)

(define marketing-file (attach-tag 'marketing
                                   '("John" "Pedro" "Alice")))

(define sales-file (attach-tag 'sales
                               '(("Doe" 27) ("Pedro" 40) ("Alice" 60))))
```

```
stklos> (get-record "Pedro" marketing-file)
"Pedro"
stklos> (get-record "Pedro" sales-file)
("Pedro" 40)
```

### Subproblem 2

In [Subproblem 1](#subproblem-1), when we called the generic headquarters
`get-record`, we had the outputs:

```
stklos> (get-record "Pedro" marketing-file)
"Pedro"
stklos> (get-record "Pedro" sales-file)
("Pedro" 40)
```

Notice that, just looking to the procedures outputs, we no longer known from
whichs division the records `"Pedro"` and `("Pedro" 40)` belongs to.

To allow further generic operations on records (such as `get-salary`), records
returned by `get-record` must be tagged with their division type.

In other words, the records **must be tagged**:

```scheme
(define (get-record employee-name file)
  (let* ((tag (type-tag file))
         (proc (get 'get-record tag)))
    (if proc
      (let ((record (proc employee-name (contents file))))
        (if record
          (attach-tag tag record)
          #f))
      (error
        "No method for type:
        GET-RECORD"
        tag))))
```

Now we can implement the generic headquarters `get-salary`:

```scheme
(define (get-salary employee-record)
  (if employee-record
    (let* ((tag (type-tag employee-record))
           (proc (get 'get-salary tag)))
      (if proc
        (proc (contents employee-record))
        (error
          "No method for type:
          GET-SALARY"
          tag)))
    #f))
```

Note that divison-level `get-salary` procedures will operate on untagged
internal records, and, each division can install its on implementation of it:

```scheme
(define (install-marketing-package)
  ;; Internal procedures
  ;; ...
  (define (get-salary record) 50)
  ;; Interface to the rest of the system
  ;; ...
  (put 'get-salary 'marketing get-salary)
  'done)
```

```scheme
(define (install-sales-package)
  ;; Internal procedures
  ;; ...
  (define (get-salary record) (cadr record))
  ;; Interface to the rest of the system
  ;; ...
  (put 'get-salary 'sales get-salary)
  'done)
```

### Subproblem 3

To implement `find-employee-record` we levarage the `get-record` procedure from
[Subproblem 2](#subproblem-2), which returns either a tagged record or `#f`,
allowing headquarters to combine results without inspecting division-file
internals.

```scheme
(define (find-employee-record employee-name files)
  (if (null? files)
    #f
    (or (get-record employee-name (car files))
        (find-employee-record employee-name (cdr files)))))
```
