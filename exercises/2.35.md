## Exercise 2.35

Redefine `count-leaves` from 2.2.2 as an accumulation:

```scheme
(define (count-leaves t)
  (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
```

## Solution

Using the structure proposed by the exercise, `accumulate` simply sums leaf
counts. This implementation has a declarative aspect and we can read like:

> "Take the list of subtrees. For each, get the number of leaves. Then sum
> them."

```scheme
(define (count-leaves t)
  (accumulate + 0 (map (lambda (subtree)
                         (if (pair? subtree)
                           (count-leaves subtree)
                           1))
                       t)))
```

Another version, that has imperative aspects, can be read like:

> "Start with 0, and for each element:\
>  if it's a pair, recursively count its leaves and add to the total;\
> otherwise, just add 1 to the total."

```scheme
(define (count-leaves t)
  (accumulate (lambda (x y)
                (if (pair? x)
                  (+ y (count-leaves x))
                  (+ y 1)))
              0 t))
```

Note that it's not that the second version is imperative in the traditional,
mutable state sense, but the first version is more declarative in its structure,
while the second is more manual and "imperative-like" in its folding function.
