[Exercise 2.42]: ./2.42.md

## Exercise 2.43

Louis Reasoner is having a terrible time doing [Exercise 2.42]. His `queens`
procedure seems to work, but it runs extremely slowly. (Louis never does manage
to wait long enough for it to solve even the 6×6 case.) When Louis asks Eva Lu
Ator for help, she points out that he has interchanged the order of the nested
mappings in the flatmap, writing it as

```scheme
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position
           new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
```

Explain why this interchange makes the program run slowly. Estimate how long it
will take Louis’s program to solve the eight-queens puzzle, assuming that the
program in [Exercise 2.42] solves the puzzle in time $T$.

## Solution

This interchange makes the program run slowly because rather than making the
recursive call once, in the outer loop, Lous Reasoner's code make the recursive
call for each element in the interval that goes from 1 to the `board-size`. In
other words, we are introducing redundant recursive calls.

We can check this behavior tracing the `queen-cols` procedures. To make it easy
to visualize, we are going to name the performant procedure as `queens` and
`queen-cols` and the slowly one `queens-slow` and `queen-slow-col`:

For `queens` the trace is shown below:

```scheme
.. -> queen-cols with args = (2)
.... -> queen-cols with args = (1)
...... -> queen-cols with args = (0)
...... <- queen-cols returns (())
.... <- queen-cols returns (((1 . 1)) ((2 . 1)))
.. <- queen-cols returns ()
```

For `queens-slow` the trace is shown below:

```scheme
.. -> queen-slow-cols with args = (2)
.... -> queen-slow-cols with args = (1)
...... -> queen-slow-cols with args = (0)
...... <- queen-slow-cols returns (())
...... -> queen-slow-cols with args = (0)
...... <- queen-slow-cols returns (())
.... <- queen-slow-cols returns (((1 . 1)) ((2 . 1)))
.... -> queen-slow-cols with args = (1)
...... -> queen-slow-cols with args = (0)
...... <- queen-slow-cols returns (())
...... -> queen-slow-cols with args = (0)
...... <- queen-slow-cols returns (())
.... <- queen-slow-cols returns (((1 . 1)) ((2 . 1)))
.. <- queen-slow-cols returns ()
```

Now, let's see what changes computationally:

Let $Q_k$ denote the call that computes all placements for the first $k$
columns.

- Correct program ([Exercise 2.42]):

  - $Q_k$ makes one recursive call to $Q_{k-1}$, and then for each result in
    $Q_{k-1}$, we try all $n$ rows
  - So the number of recursive invocations of $Q_{k-1}$ per $Q_k$ is $1$

- Louis's program:
  - For each row, $Q_k$ makes one recursive call to $Q_{k-1}$.
  - So the number of recursive invocations of $Q_{k-1}$ per $Q_k$ is $n$

But this growths like a tree

- $Q_{k-1}$ calls in $Q_{k}$ = $n$
- $Q_{k-2}$ calls in $Q_{k}$ = $n^2$
- ...
- $Q_0$ calls in $Q_{k}$ = $n^n$

So if the program in [Exercise 2.42] solves the puzzle in time $T$, we expect
Louis’s program to take $n^n \times T$ to solve the puzzle.

But here we have a subtle but important consideration about Louis’s time to
solve the puzzle:

- Mathematically, we expect it to take $n^n \times T$
- In practice, we expect it to take $n^{n-1} \times T$

Why? Because in the base case, when calling `(queen-cols 0)`, even though
Louis's version makes $n$ calls to `(queen-cols 0)` rather than one by the
correct version, this procedure is trivial, meaning there is no "heavy lifting",
it just returns an empty list. So in practice, we can "exclude" the base case
recursion.
