## Exercise 2.73

2.3.2 described a program that performs symbolic differentiation:

```scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product
            (multiplier exp)
            (deriv (multiplicand exp) var))
           (make-product
            (deriv (multiplier exp) var)
            (multiplicand exp))))
        ⟨more rules can be added here⟩
        (else (error "unknown expression type:
                      DERIV" exp))))
```

We can regard this program as performing a dispatch on the type of the
expression to be differentiated. In this situation the “type tag” of the datum
is the algebraic operator symbol (such as +) and the operation being performed
is `deriv`. We can transform this program into data-directed style by rewriting
the basic derivative procedure as

```scheme
(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp)
           (if (same-variable? exp var)
               1
               0))
         (else ((get 'deriv (operator exp))
                (operands exp)
                var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
```

1. Explain what was done above. Why can’t we assimilate the predicates `number?`
   and `variable?` into the data-directed dispatch?
2. Write the procedures for derivatives of sums and products, and the auxiliary
   code required to install them in the table used by the program above.
3. Choose any additional differentiation rule that you like, such as the one for
   exponents ([Exercise 2.56](./2.56.md)), and install it in this data-directed
   system.
4. In this simple algebraic manipulator the type of an expression is the
   algebraic operator that binds it together. Suppose, however, we indexed the
   procedures in the opposite way, so that the dispatch line in `deriv` looked
   like

   ```scheme
   ((get (operator exp) 'deriv)
    (operands exp) var)
   ```

   What corresponding changes to the derivative system are required?

## Solution

### 1. Explain what was done above. Why can’t we assimilate the predicates number? and variable? into the data-directed dispatch?

We've added additivity to our program by moving the dispatch mechanism from
syntax (`cond`) to data (`get`).

In the dispatch-on-type implementation, we can see a line that indicates
`⟨more rules can be added here⟩`, meaning that, to add new operations, we need
to touch the generic procedure. This is a sympton of a program not designed to
be additive. On the other hand, for the data-direct implementation, to add a new
rule we could implement this new rule in isolation, and just "install" the rule
package inside the operation x data type table.

To understand why we could not assimilate the predicates `number?` and
`variable?`, we need to remember that data-directed dispatch assumes that:

1. Every datum has a uniform representation
2. The "type" can be extracted mechanically

But

- Numbers are atomic, not compound
- Variables are symbols that mean something contextually, not structurally

We could write a procedure that incorporate this mechanism, but we are just
moving the case analysis somewhere else:

```scheme
(define (deriv exp var) ((get 'deriv (operator exp)) (operands exp) var))

(define (operator exp)
  (cond ((number? exp) 'number)
        ((variable? exp) 'variable)
        (else (car exp))))

(define (operands exp)
  (cond ((number? exp) exp)
        ((variable? exp) exp)
        (else (cdr exp))))

(define (install-number-package)
  (define (deriv exp var) 0)
  (put 'deriv '(number) deriv)
  'done)
```

In other words:

- We can force numbers and variables into the table
- But then `operator` becomes a disguised `cond`
- So additivity is no longer uniform

### 2. Write the procedures for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.

```scheme
(define (install-sum-package)
  (define (addend exp) (car exp))
  (define (augend exp) (cadr exp))
  (define (make-sum x y) (list '+ x y))
  (define (deriv-sum exp var)
    (make-sum (deriv (addend exp) var)
              (deriv (augend exp) var)))
  (put 'deriv '+ deriv-sum)
  'done)

(define (install-product-package)
  (define (multiplier exp) (car exp))
  (define (multiplicand exp) (cadr exp))
  (define (make-sum x y) (list '+ x y))
  (define (make-product x y) (list '* x y))
  (define (deriv-product exp var)
    (make-sum
      (make-product
        (multiplier exp)
        (deriv (multiplicand exp) var))
      (make-product
        (deriv (multiplier exp) var)
        (multiplicand exp))))
  (put 'deriv '* deriv-product)
  'done)
```

Note that the derivative procedures are not simplifying the algebraic
expressions just for the sake of simplicity, and to keep the focus on
data-direct programming and additivity rather than derivative procedures.

Also notice that the generic operation (`deriv`) fixes the interface that the
derivative packages must obey:

```
input: operands + variable
output: expression
```

This is why we are not reusing the selectors (`addend`, `augend`, `multiplier`,
etc) from previous sections.

### 3. Choose any additional differentiation rule that you like, such as the one for exponents ([Exercise 2.56](./2.56.md)), and install it in this data-directed system.

Note that we don't even need to touch previous code. We just add:

```scheme
(define (install-exponentiation-package)
  (define (base exp) (car exp))
  (define (exponent exp) (cadr exp))
  (define (make-product x y) (list '* x y))
  (define (make-exponentiation base exponent) (list '** base exponent))
  (define (deriv-exponentiation exp var)
    (make-product
      (exponent exp)
      (make-product
        (make-exponentiation (base exp)
                             (- (exponent exp) 1))
        (deriv (base exp) var))))
  (put 'deriv '** deriv-exponentiation)
  'done)

(install-exponentiation-package)
```

Note that the derivative procedures are not simplifying the algebraic
expressions just for the sake of simplicity, and to keep the focus on
data-direct programming and additivity rather than derivative procedures.

### 4. In this simple algebraic manipulator the type of an expression is the algebraic operator that binds it together. Suppose, however, we indexed the procedures in the opposite way, so that the dispatch line in deriv looked like `((get (operator exp) 'deriv) (operands exp) var)`. What corresponding changes to the derivative system are required?

Inside the code we would only need to swap the the first two arguments of `put`
in all package installation procedures. Remember that `put` and `get` work
together as abstractions like this:

- `(put ⟨op⟩ ⟨type⟩ ⟨item⟩)`: installs the ⟨item⟩ in the table, indexed by the
  ⟨op⟩ and the ⟨type⟩.
- `(get ⟨op⟩ ⟨type⟩)`: looks up the ⟨op⟩, ⟨type⟩ entry in the table and returns
  the item found there. If no item is found, get returns false.

But this simple code change represents a huge change on how we organize and
think about our code.

In the original system `(get 'deriv '+)` we care deeply about one operation. We
would think like:

> I want to fully understand and extend derivation

So the code organization would benit from something like this:

```scheme
(define (install-deriv-package)
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  (put 'deriv '** deriv-expt)
  (put 'deriv 'sin deriv-sin)
  (put 'deriv 'log deriv-log)
  ...)
```

Here the mental model is operation-centric. We care about how the operation is
performed on different types.

On the other hand, in the reverse system `(get '+ 'deriv)` we care deeply about
one operator (type). We think would think like:

> The + operator knows how to behave

So the code organization would benit from something like this:

```scheme
(define (install-plus-package)
  (put '+ 'deriv deriv-sum)
  (put '+ 'simplify simplify-sum)
  (put '+ 'eval eval-sum)
  (put '+ 'pretty pretty-sum))
```

Here the mental model is type-centric. We care about how type handle operations.
