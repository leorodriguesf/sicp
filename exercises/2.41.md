## Exercise 2.41

Write a procedure to find all ordered triples of distinct positive integers $i$
, $j$ , and $k$ less than or equal to a given integer $n$ that sum to a given
integer $s$.

## Solution

First we define a higher order procedure that is common when dealing with nested
maps:

```scheme
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
```

Now, using our own representations we write:

```scheme
(define (make-triple a b c)
  (list a b c))

(define (triple-left triple) (car triple))
(define (triple-center triple) (cadr triple))
(define (triple-right triple) (caddr triple))

(define (sum-triple triple)
  (+ (triple-left triple)
     (triple-center triple)
     (triple-right triple)))

(define (triple-has-duplicates? triple)
  (let ((tl (triple-left triple))
        (tc (triple-center triple))
        (tr (triple-right triple)))
      (or (= tl tc)
          (= tl tr)
          (= tc tr))))

(define (distinct-triple? triple)
  (not (triple-has-duplicates? triple)))

(define (make-triples n)
  (let ((interval (enumerate-interval 1 n)))
    (flatmap
      (lambda (i)
        (flatmap (lambda (j)
                   (map (lambda (k)
                          (make-triple i j k))
                        interval))
                 interval))
      interval)))

(define (filter pred? seq)
  (cond ((null? seq) '())
        ((pred? (car seq))
         (cons (car seq) (filter pred? (cdr seq))))
        (else (filter pred? (cdr seq)))))

(define (triples-sum-s n s)
  (filter (lambda (triple)
            (and
              (distinct-triple? triple)
              (= (sum-triple triple) s)))
          (make-triples n)))
```
