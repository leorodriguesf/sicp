## Exercise 2.11

In passing, Ben also cryptically comments: “By testing the signs of the endpoints of the intervals, it is possible to break `mul-interval` into nine cases, only one of which requires more than two multiplications.” Rewrite this procedure using Ben’s suggestion.

## Solution

```scheme
#lang racket

(define (mul-interval x y)
  (let ((lx (lower-bound x))
        (ux (upper-bound x))
        (ly (lower-bound y))
        (uy (upper-bound y)))
    (cond
      ;; Case 1: Positive x Positive
      ((and (>= lx 0) (>= ly 0))
       (make-interval (* lx ly) (* ux uy)))

      ;; Case 2: Positive x Zero-spanning
      ((and (>= lx 0) (<= ly 0) (>= uy 0))
       (make-interval (* ux ly) (* ux uy)))

      ;; Case 3: Positive x Negative
      ((and (>= lx 0) (<= uy 0))
       (make-interval (* ux ly) (* lx uy)))

      ;; Case 4: Zero-spanning x Positive
      ((and (<= lx 0) (>= ux 0) (>= ly 0))
       (make-interval (* lx uy) (* ux uy)))

      ;; Case 5: Zero-spanning x Zero-spanning
      ((and (<= lx 0) (>= ux 0) (<= ly 0) (>= uy 0))
       (let ((p1 (* lx ly))
             (p2 (* lx uy))
             (p3 (* ux ly))
             (p4 (* ux uy)))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))

      ;; Case 6: Zero-spanning x Negative
      ((and (<= lx 0) (>= ux 0) (<= uy 0))
       (make-interval (* ux ly) (* lx uy)))

      ;; Case 7: Negative x Positive
      ((and (<= ux 0) (>= ly 0))
       (make-interval (* lx uy) (* ux ly)))

      ;; Case 8: Negative x Zero-spanning
      ((and (<= ux 0) (<= ly 0) (>= uy 0))
       (make-interval (* lx uy) (* lx ly)))

      ;; Case 9: Negative x Negative
      ((and (<= ux 0) (<= uy 0))
       (make-interval (* ux uy) (* lx ly))))))
```
