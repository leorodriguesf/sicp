## Exercise 2.32

We can represent a set as a list of distinct elements, and we can represent the
set of all subsets of the set as a list of lists. For example, if the set is
`(1 2 3)`, then the set of all subsets is
`(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))`. Complete the following definition
of a procedure that generates the set of subsets of a set and give a clear
explanation of why it works:

```scheme
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map ⟨??⟩ rest)))))
```

## Solution

```scheme
(define (subsets s)
  (if (null? s)
    (list '())
    (let ((rest (subsets (cdr s))))
      (append rest (map (lambda (element)
                          (cons (car s) element))
                        rest)))))
```

This procedure is very good to enforce that, when dealing with abstractions, we
need to change the way we think about computation, otherwise it will be
difficult to follow the process generated. Instead of stepping through each
execution line, we should think recursively at an abstract level:

- Compute the subsets of the rest of the set. I know I didn't write `subsets`
  yet, but I am assuming it will give me the correct result

  ```scheme
  (let ((rest (subsets (cdr s))))
  ```

- For each subset in `rest`, I want to produce a new subset that includes
  `(car s)` in front:

  ```scheme
  (map (lambda (element)
      (cons (car s) element))
      rest)
  ```

- Return the union of `rest` and the new subsets via `append`.
