## Exercise 2.82

Show how to generalize `apply-generic` to handle coercion in the general case of
multiple arguments. One strategy is to attempt to coerce all the arguments to
the type of the first argument, then to the type of the second argument, and so
on. Give an example of a situation where this strategy (and likewise the
two-argument version given above) is not sufficiently general. (Hint: Consider
the case where there are some suitable mixed-type operations present in the
table that will not be tried.)

## Solution

Using the strategy of coercing all the arguments to the same type:

```scheme
(define (apply-generic op . args)
  (define (make-uniform-types types to) (map (lambda (x) to) types))

  (define (try-coerce-all args target)
    (define (coerce-one x)
      (let* ((tag (type-tag x))
             (coercion-proc (get-coercion tag target)))
        (if (equal? tag target)
          x
          (if coercion-proc
            (coercion-proc x)
            #f))))

    (define (loop rest result)
      (if (null? rest)
        (reverse result)
        (let ((coerced (coerce-one (car rest))))
          (if coerced
            (loop (cdr rest) (cons coerced result))
            #f))))
    (loop args '()))

  (let* ((type-tags (map type-tag args))
         (proc (get op type-tags)))
    (define (try lst)
      (if (null? lst)
        (error
           "No method for these types"
           (list op type-tags))
        (let* ((type-to-try (car lst))
               (uniform-types (make-uniform-types type-tags type-to-try))
               (proc (get op uniform-types)))
          (if proc
            (let ((all-coerced (try-coerce-all args type-to-try)))
              (if all-coerced
                (apply proc (map contents all-coerced))
                (try (cdr lst))))
            (try (cdr lst))))))
    (if proc
      (apply proc (map contents args))
      (try type-tags))))
```

```scheme
(define (install-complex-package)
  ;; ...
  (put 'add3c '(complex complex complex)
       (lambda (z1 z2 z3)
         (tag (add-complex z1 (add-complex z2 z3)))))
  'done)

(define (add3c z1 z2 z3) (apply-generic 'add3c z1 z2 z3))
```

```
stklos> (define a (make-scheme-number 1))
;; a
stklos> (define b (make-complex-from-real-imag 1 1))
;; b
stklos> (define c (make-scheme-number 1))
;; c
stklos> (add3c a b c)
(complex rectangular 3 . 1)
```

Note that this implementation does not work when we have a mixed of operation
defined in the operations table. For example:

```scheme
(put 'some-mixed-op '(complex rational)
      ;...)

(define (some-mixed-op z r) (apply-generic 'some-mixed-op z r))

(define z (make-complex-from-real-imag 1 1))
(define r (make-rational 1 1))
(some-mixed-op r z)
```

would not work because we would look for a procedure defined for either
arguments as is `(rational complex)`, `(complex complex)` or
`(rational rational)`, but not for a procedure with types mixed.
