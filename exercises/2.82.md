## Exercise 2.82

Show how to generalize `apply-generic` to handle coercion in the general case of multiple arguments. One strategy is to attempt to coerce all the arguments to the type of the first argument, then to the type of the second argument, and so on. Give an example of a situation where this strategy (and likewise the two-argument version given above) is not sufficiently general. (Hint: Consider the case where there are some suitable mixed-type operations present in the table that will not be tried.)

## Solution

```scheme
(define (apply-generic op . args)
  (let* ((type-tags (map type-tag args))
         (proc (get op type-tags)))
    (define (try lst)
      (if (null? lst)
        (error 
           "No method for these types"
           (list op type-tags))
        (let* ((type-to-try (car lst))
               (same-types (convert-to-same-types type-tags type-to-try))
               (proc (get op same-types)))
          ;; TODO: improve error when no coercion
          (if proc
            (apply proc (map contents (map (lambda (x)
                                             (if (eq? (type-tag x) type-to-try)
                                               x
                                               ((get-coercion (type-tag x) type-to-try) x)))
                                           args)))
            (try (cdr lst))))))
    (if proc
      (apply proc (map contents args))
      (try type-tags))))
```

```scheme
(define (install-complex-package)
  ;; ...
  (put 'add3c '(complex complex complex)
       (lambda (z1 z2 z3)
         (tag (add-complex z1 (add-complex z2 z3)))))
  'done)

(define (add3c z1 z2 z3) (apply-generic 'add3c z1 z2 z3))
```

```
stklos> (define a (make-scheme-number 1))
;; a
stklos> (define b (make-complex-from-real-imag 1 1))
;; b
stklos> (define c (make-scheme-number 1))
;; c
stklos> (add3c a b c)
(complex rectangular 3 . 1)
```