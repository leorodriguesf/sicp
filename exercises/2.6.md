## Exercise 2.6

In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

```scheme
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
```

This representation is known as _Church numerals_, after its inventor, Alonzo Church, the logician who invented the $λ$-calculus.

Define `one` and `two` directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate `(add-1 zero)`). Give a direct definition of the addition procedure `+` (not in terms of repeated application of add-1).

## Solution

First lets use the substitution model to evaluate `(add-1 zero)`:

```scheme
(add-1 zero)

(add-1 (lambda (f) (lambda (x) x)))

(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))

(lambda (f) (lambda (x) (f x)))
```

We can notice that the idea of adding 1 to zero to produce 1 is equivalent of applying the function `f` one time.

With this idea in mind we can write `one` and `two`:

```scheme
(define one (lambda (f) (lambda (x) (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))
```

Now we have all the abstact concepts to write down the `+` procedure:

- `(add-1 n)` gives the idea of applying `f` one more time than `n`
- `(one)` and `(two)` gives the idea of applying `f` one times and two times respectively

We can conclude that `+` should be something like:

1. Apply `f` `a` times to x, to produce output
2. Apply `f` `b` times to output of step 1, to produce output

```scheme
(define (+ a b)
  (lambda (f) (lambda (x) ((b f) ((a f) x)))))
```

The cool thing is that, just as in common arithmetic, we can check that `+` is commutative by writing:

```scheme
(define (+ a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
```
