## Exercise 2.81

Louis Reasoner has noticed that `apply-generic` may try to coerce the arguments to each other’s type even if they already have the same type. Therefore, he reasons, we need to put procedures in the coercion table to coerce arguments of each type to their own type. For example, in addition to the `scheme-number->complex` coercion shown above, he would do:

```scheme
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

(put-coercion 'scheme-number 'scheme-number
              scheme-number->scheme-number)

(put-coercion 'complex 'complex 
              complex->complex)
```

1. With Louis’s coercion procedures installed, what happens if `apply-generic` is called with two arguments of type `scheme-number` or two arguments of type `complex` for an operation that is not found in the table for those types? For example, assume that we’ve defined a generic exponentiation operation:

    ```scheme
    (define (exp x y) 
      (apply-generic 'exp x y))
    ```
    and have put a procedure for exponentiation in the Scheme-number package but not in any other package:

    ```scheme
    ;; following added to Scheme-number package
    (put 'exp 
        '(scheme-number scheme-number)
        (lambda (x y) 
          (tag (expt x y)))) 
          ; using primitive expt
    ```

    What happens if we call `exp` with two complex numbers as arguments?

2. Is Louis correct that something had to be done about coercion with arguments of the same type, or does `apply-generic` work correctly as is?

3. Modify `apply-generic` so that it doesn’t try coercion if the two arguments have the same type.

## Solution

1. We would have an infinite recursion, because even though the procedure is not found in the operation table, the coercion is a valid procedure with a recursive call to `apply-generic` with types coerced to itself
2. `apply-generic` work as is. It is pointless to try to coerce arguments with the same type, because the whole idea of coercion, after all, is to try to convert an argument type to each other's type hoping to find a procedure that does exist in the operation table. Because the first thing `apply-generic` does is to look up the operation for the arguments types, if they are of the same kind, and the procedure is not present in the operation table, coercing to itself will not solve the problem, and even worse, will result in a infinite loop, just as explained at subproblem 1.
3. Implementation to avoid coercion of two arguments of the same type:
    ```scheme
    (define (apply-generic op . args)
      (let ((type-tags (map type-tag args)))
        (define (show-error)
          (error
            "No method for these types"
            (list op type-tags)))
        (let ((proc (get op type-tags)))
          (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags)))
                (if (eq? type1 type2)
                  (show-error)
                  (let ((a1 (car args))
                        (a2 (cadr args))
                        (t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (cond (t1->t2 (apply-generic op (t1->t2 a1) a2))
                          (t2->t1 (apply-generic op a1 (t2->t1 a2)))
                          (else (show-error))))))
              (show-error))))))
    ```