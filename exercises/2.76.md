## Exercise 2.76

As a large system with generic operations evolves, new types of data objects or
new operations may be needed. For each of the three strategies — generic
operations with explicit dispatch, data-directed style, and
message-passing-style—describe the changes that must be made to a system in
order to add new types or new operations. Which organization would be most
appropriate for a system in which new types must often be added? Which would be
most appropriate for a system in which new operations must often be added?

## Solution

### Generic operations with explicit dispatch

```scheme
(define (real-part-rectangular z)
  ;...
)

(define (real-part-polar z)
  ;...
)

(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type:
               REAL-PART" z))))
```

To add a new type we must:

- Add a new clause to all generic procedures
- Implement specific procedures that will be dispatched by the generic
  procedures

```diff
(define (real-part-rectangular z)
  ;...
)

(define (real-part-polar z)
  ;...
)

+(define (real-part-matrix z)
+  ;...
+)

(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
+        ((matrix? z)
+         (real-part-matrix (contents z)))
        (else (error "Unknown type:
               REAL-PART" z))))
```

To add a new operation we must:

- Write a generic procedure to handle all types
- Implement specific procedures that will be dispatched by the new generic
  procedure

```diff
+(define (imag-part-rectangular z)
+  ;...
+)

+(define (imag-part-polar z)
+  ;...
+)

+(define (imag-part-matrix z)
+  ;...
+)

+(define (imag-part z)
+  (cond ((rectangular? z)
+         (imag-part-rectangular (contents z)))
+        ((polar? z)
+         (imag-part-polar (contents z)))
+        ((matrix? z)
+         (imag-part-matrix (contents z)))
+        (else (error "Unknown type:
+               IMAG-PART" z))))
```

### Data-directed style

```scheme
(define (install-rectangular-package)
  (define (real-part z)
    ;...
  )

  (put 'real-part '(rectangular) real-part)
'done)

(define (real-part z)
  (apply-generic 'real-part z))
```

To add a new type we must:

- Install all generic procedures for the new type

These installations are **local to the new package**, and no existing code
changes.

```diff
(define (install-rectangular-package)
  (define (real-part z)
    ;...
  )

  (put 'real-part '(rectangular) real-part)
'done)

+(define (install-matrix-package)
+  (define (real-part z)
+    ;...
+  )
+
+  (put 'real-part '(matrix) real-part)
+'done)

(define (real-part z)
  (apply-generic 'real-part z))
```

To add a new operation we must:

- Install new operation to all types
- Write the generic procedure that wraps the specific operation

Note that we must touch every existing package! In other words, the cost is
**distributed**, not centralized.

```diff
(define (install-rectangular-package)
  (define (real-part z)
    ;...
  )

+  (define (imag-part z)
+    ;...
+  )

  (put 'real-part '(rectangular) real-part)
+  (put 'imag-part '(rectangular) imag-part)
'done)

(define (install-matrix-package)
  (define (real-part z)
    ;...
  )

+  (define (imag-part z)
+    ;...
+  )

  (put 'real-part '(matrix) real-part)
+  (put 'imag-part '(matrix) imag-part)
'done)

(define (real-part z)
  (apply-generic 'real-part z))

+(define (imag-part z)
+  (apply-generic 'imag-part z))
```

### Message-passing style

```scheme
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          (else
           (error "Unknown op:
            MAKE-FROM-REAL-IMAG" op))))
  dispatch)
```

To add a new type we must:

- Create a new data object that dispatch all expected operations (messages)

Most importantly, a new type is **entirely self-contained**:

- No global tables
- No generic dispatchers need to be modified

```diff
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          (else
           (error "Unknown op:
            MAKE-FROM-REAL-IMAG" op))))
  dispatch)

+(define (make-matrix-from-real-imag x y)
+  (define (dispatch op)
+    (cond ((eq? op 'real-part) ;...)
+          (else
+           (error "Unknown op:
+            MAKE-MATRIX-FROM-REAL-IMAG" op))))
+  dispatch)
```

To add a new operation we must:

- Add a new clause to all data objects

```diff
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
+          ((eq? op 'imag-part) ;...)
          (else
           (error "Unknown op:
            MAKE-FROM-REAL-IMAG" op))))
  dispatch)

(define (make-matrix-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) ;...)
+          ((eq? op 'imag-part) ;...)
          (else
           (error "Unknown op:
            MAKE-MATRIX-FROM-REAL-IMAG" op))))
  dispatch)
```

### Tradeoffs

In general, we are aiming to implement the new functionality (either new types
or new operations) in a self-contained fashioned. Looking at the diffs in the
examples above, we can spot if the changes to the existing code are distributed
or centralized, and this is a good tool for measuring tradeoffs.

Message-passing is the best options for a system in which new types are often
added, because it has the strogest encapsulation of all the three strategies:

- No global tables
- No generic dispatchers

```diff
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          (else
           (error "Unknown op:
            MAKE-FROM-REAL-IMAG" op))))
  dispatch)

+(define (make-matrix-from-real-imag x y)
+  (define (dispatch op)
+    (cond ((eq? op 'real-part) ;...)
+          (else
+           (error "Unknown op:
+            MAKE-MATRIX-FROM-REAL-IMAG" op))))
+  dispatch)
```

On the other hand, generic operations with explicit dispatch would be the best
option for a system in which new operations are often added.

```diff
+(define (imag-part-rectangular z)
+  ;...
+)

+(define (imag-part-polar z)
+  ;...
+)

+(define (imag-part-matrix z)
+  ;...
+)

+(define (imag-part z)
+  (cond ((rectangular? z)
+         (imag-part-rectangular (contents z)))
+        ((polar? z)
+         (imag-part-polar (contents z)))
+        ((matrix? z)
+         (imag-part-matrix ((contents z))))
+        (else (error "Unknown type:
+               IMAG-PART" z))))
```

The data-directed style would be the best option when adding a mix of types and
operations, since it works well for both.

We can draw a table that summarizes what was discussed above:

| Strategy          | New Types | New Operations |
| ----------------- | --------- | -------------- |
| Explicit dispatch | ❌ worst  | ✅ best        |
| Data-directed     | ✅ good   | ❌ costly      |
| Message-passing   | ✅ best   | ❌ worst       |
